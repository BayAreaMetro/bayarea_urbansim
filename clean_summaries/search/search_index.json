{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bay Area UrbanSim (BAUS)","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Bay Area UrbanSim (BAUS) is a land use or urban economic model used to forecast metropolitan growth, study urban policies, and evaluate transportation projects at the Metropolitan Transportation Commission (MTC). It is written in Python and is a customized version of the popular UrbanSim model developed by Professor Paul Waddell over the last few decades. BAUS simulates the movement of households and employees within the region, and the construction of new buildings to hold those households and employees. In this manner, it is used to incrementally forecast potential future urban growth trajectories.</p>"},{"location":"#contents","title":"Contents","text":"<pre><code>[Model Overview]()\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#the-configuration-file-structure-for-bay-area-urbansim-baus-and-a-description-of-each-file-model-configurations-files-are-stored-in-a-configs-folder-in-the-model-repository-they-specify-model-settings-such-as-model-estimation-constants-and-assumptions","title":"The configuration file structure for Bay Area UrbanSim (BAUS) and a description of each file. Model configurations files are stored in a <code>configs</code> folder in the model repository. They specify model settings such as model estimation constants and assumptions.","text":""},{"location":"configuration/#bayarea_urbnasimconfigs","title":"bayarea_urbnasim/configs","text":""},{"location":"configuration/#adjusters","title":"adjusters/","text":"name description cost_shifters.yaml Multipliers to cost, currently specified by county, used to calibrate the model. development_caps_asserted.yaml Caps on development, either residential or office, used to calibrate the model. (TODO: remove any base year existing policy caps entangled here). employment_relocation_rates_overwrites.csv These overwrite the relocation rates in employment_relocation_rates.csv to calibrate the model, e.g. leave government sector jobs in San Francisco City Hall's TAZ. sqft_per_job_adjusters Multipliers to the number of sqft used by each job, defined in the model's developer settings, which modify the number of jobs that can occupy a building. This is used to calibrate the model, e.g. reflect CBD job densities or adjust vacancy rates by superdistrict. The inputs file telecommute_sqft_per_job_adjusters.csv uses alternative multipliers for for the forecast years in place of these, if the strategy is enabled. (TODO: Disentangle the k-factors and the policy application in these two files. In the meantime, use both files as is done in the PBA50 No Project). zoning_adjusters.yaml Adjusters used to modify the model's zoning data."},{"location":"configuration/#accessibility","title":"accessibility/","text":"name description accessibility_settings.yaml Settings for Pandana, the model's endogenous accessibility calculations. neighborhood_vars.yaml Settings for calculating local accessibility variables during the model run. regional_vars.yaml Settings for calculating regional accessibility variables during the model run. price_vars.yaml Settings for calculating local accessibility variables on price during the model run."},{"location":"configuration/#developer","title":"developer/","text":"name description developer_settings.yaml Settings for the model's developer and feasibility models. residential_vacancy_rates.csv Residential vacancy rates for the residential developer model, separated from the main developer settings into this file to allow them to vary by year."},{"location":"configuration/#hedonics","title":"hedonics/","text":"name description price_settings.yaml Settings for the model's price simulation and supplydemand equilibration of price. nrh.yaml Non-residential hedonic price model specification. rrh.yaml Residential rent hedonic price model specification. rsh.yaml Residential sales hedonic price model specification."},{"location":"configuration/#location_choice","title":"location_choice/","text":"name description elcm.yaml Employment location choice model specification, segemented by six employment sectors. hlcm_owner.yaml Household location choice model specification segmented by income quartiles. The models are estimated for owner households. hlcm_owner_lowincome.yaml This uses the same specification and estimated coefficients as hlcm_owner. The only difference is that it is used to only low income households to choose deed-restricted owner units. hlcm_owner_lowincome_no_unplaced.yaml This uses the same specification and estimated coefficients as hlcm_owner, but allows owners of all incomes into deed-restricted owner units to cover any gaps in assignment. hlcm_owner_no_unplaced.yaml This uses the same specification and estimated coefficients as hlcm_owner, but does another round of placements of owners, this time into non-deed-restricted owner units, to cover any gaps in assignment. hlcm_renter.yaml Household location choice model specification segmented by income quartiles. The models are estimated for rental households. hlcm_renter_lowincome.yaml This uses the same specification and estimated coefficients as hlcm_renter. The only difference is that it is used to only low income households to choose deed-restricted rental units. hlcm_renter_lowincome_no_unplaced.yaml This uses the same specification and estimated coefficients as hlcm_renter, but allows renters of all incomes into deed-restricted rental units to cover any gaps in assignment. hlcm_renter_no_unplaced.yaml This uses the same specification and estimated coefficients as hlcm_renter, but does another round of placement of renters, this time into non-deed-restricted rental units, to cover any gaps in assignment. HLCM Model Estimation Choosers: Filters Estimation Alternatives: Filters Simulation Choosers: Filters Simulation Alternatives: Filters owner Owners - Owners Owner Units owner_lowincome Owners - Low-Income Owners Affordable Owner Units owner_lowincome_no_unplaced - - Owners Affordable Owner Units owner_no_unplaced Owners - Owners Market-Rate Owner Units renter Renters - Renters Renters Units renter_lowincome Renters - Low-Income Renters Affordable Rental Units renter_lowincome_no_unplaced - - Renters Affordable Rentual Units renter_no_unplaced Renters - Renters Market Rate Rental Units"},{"location":"configuration/#transition_relocation","title":"transition_relocation/","text":"name description employment_relocation_rates.csv A file with the probability of a job relocating during a time step in the forecast, by TAZ and by employment sector. Pairs with employment_relocation_rates.csv which overwrites the model probabilities with calibration factors. household_relocation_rates.csv A file with the probability of a household relocating during a time step in the forecast, by TAZ, income, and tenure. Pairs with renter_protections_relocation_rates_overwrites.csv which overwrites model probabilities with different relocation rates when the renter protections strategy is enabled. transition_relocation_settings.yaml Settings for the transition and relocation models."},{"location":"configuration/#mappingyaml","title":"mapping.yaml","text":"<p>Mapping used in the model to relate variables to one another.</p>"},{"location":"configuration/#pathsyaml","title":"paths.yaml","text":"<p>Variables that store file names for use in the model code.</p>"},{"location":"input/","title":"Input","text":""},{"location":"input/#the-inputs-structure-for-bay-area-urbansim-baus-and-a-description-of-each-input-model-input-files-are-stored-in-an-inputs-folder-to-be-called-by-the-model-they-are-often-run-specific-and-contain-the-data-used-to-run-the-model-such-as-base-year-datasets-and-policy-inputs","title":"The inputs structure for Bay Area UrbanSim (BAUS) and a description of each input. Model input files are stored in an <code>inputs</code> folder to be called by the model. They are often run-specific and contain the data used to run the model, such as base year datasets and policy inputs.","text":""},{"location":"input/#inputs","title":"inputs/","text":""},{"location":"input/#accessibility","title":"accessibility/","text":""},{"location":"input/#pandana","title":"pandana/","text":"name description tmnet.h5 Travel model network information for calculating accessibility within the model using Pandana osm_bayarea4326.h5 Street network information for calculating accessibility within the model using Pandana landmarks.csv Locations of a few major landmarks in the region for accessibility calculations. regional_poi_distances.csv The pre-computed distances from each travel model node to each landmark. bart_stations.csv A list of BART stations and their locations so that distance to BART can calculated. logsums.csv A set of base year logsums from the travel model."},{"location":"input/#travel_model","title":"travel_model/","text":"name description AccessibilityMarkets_[year].csv A travel model output file that incorportates travel model run logsums into the forecast, by year. mandatoryAccessibilities_[year].csv A travel model output file that incorportates travel model run logsums into the forecast, by year. nonMandatoryAccessibilities_[year].csv A travel model output file that incorportates travel model run logsums into the forecast, by year."},{"location":"input/#basis_inputs-in-progress","title":"basis_inputs (in progress)/","text":""},{"location":"input/#crosswalks","title":"crosswalks/","text":"name desription parcel_to_maz22.csv A lookup table from parcels to Travel Model Two MAZs. parcel_to_taz1454sub.csv A lookup table from parcels to Travel Model One TAZs. parcels_geography.csv A lookup table from parcels to jurisdiction, growth geographies, UGB areas, greenfield areas, and a concatenation of these used to join these geographies zoning_mods.csv, to apply zoning rules within them. census_id_to_name.csv Maps census id from parcels_geography to name so it can be used. maz_geography A lookup between MAZ, TAZ2, and county. maz22_taz1454 A lookup between MAZ and TAZ1. superdistricts_geography.csv A map of superdistrict numbers, names, and their subregion. taz_geography.csv A lookup between TAZ1, supedisctrict, and county."},{"location":"input/#edits","title":"edits/","text":"name description data_edits.yaml Settings for editing the input data in the model code, e.g. clipping values. manual_edits.csv Overrides the current h5 data using the table name, attribute name, and new value, so we don't have to generate a new one each time. household_building_id_overrides.csv Moves households to match new city household totals during the data preprocessing. tpp_id_2016.csv Updates tpp_ids after changes were made to the ids."},{"location":"input/#existing_policy","title":"existing_policy/","text":"name description development_caps.yaml Base year job cap policies in place in jurisdictions (TODO: remove the asserted development capsk-factors entangled here.) inclusionary.yaml Base year inclusionary zoning policies in place in jurisdictions (TODO: have all model runs inherit these, even if an inclusionary stratey is applied)."},{"location":"input/#hazards","title":"hazards/","text":"name desctiption slr_progression.csv The sea level rise level, for each forecast year. slr_inundation.csv The sea level rise level at which each inundation parcel becomes inundated, for each forecast year. Rows marked with \"100\" are parcels where sea level rise has been mitigated, either through planned projects or a plan strategy."},{"location":"input/#parcels_buildings-agents","title":"parcels_buildings-agents/","text":"name description bayarea_v3.h5 Base year database of households, jobs, buildings, and parcels. The data is pre-processed in pre-processing.py. costar.csv Commercial data from CoStar, including non-residential price to inform the price model. development_projects.csv The list of projects that have happened since the base data, or buildings in the development pipeline.  This file tends to have more attributes than we use in the model. deed_restricted_zone_totals.csv An approximate number of deed restricted units per TAZ to assign randomly within the TAZ. baseyear_taz_controls.csv Base year control totals by TAZ, to use for checking and refining inputs. The file includes number of units, vacancy rates, and employment by sector (TODO: add households). sfbay_craisglist.csv Craigslist data to inform rental unit information and model tenure."},{"location":"input/#zoning","title":"zoning/","text":"name description zoning_parcels.csv A lookup table from parcels to zoning_id, zoning area information, and a \"nodev\" flag (currently all set to 0). zoning_lookup.csv The existing zoning for each jurisdiction, assigned to parcels with the \"id\" field. Fields include the city name, city id, and the name of the zoning. The active attributes are max_dua, max_far, and max_height, all of which must be respected by each development."},{"location":"input/#plan_strategies-optional","title":"plan_strategies (optional)/","text":"name description accessory_units.csv A file to add accessory dwelling units to jurisdictions by year, simulating policy to allow or reduce barriers to ADU construction in jurisdictions (TODO: Make this a default policy). account_strategies.yaml This files contains the settings for all strategies in a model run that use accounts. The file may include account settings (e.g., how much to spend, where to spend) for development_caps_strategy.yaml A file that specifies a strategy to limit development (generally office development) to a certain number of residential units andor job spaces. inclusionary_strategy.yaml A file to apply an inclusionary zoning strategy by geography and inclusionary housing requirement percentage. preservation.yaml A file to apply an affordable housing preservation strategy through specifying geography and target number of units for preservation. profit_adjustment_stratgies.yaml This file contains the settings for all strategies in a model run which modify the profitability of projects thus altering their feasibility. The file may include profit adjustment settings (e.g., the percent change to profit) for renter_protections_relocation_rates_overwrites The rows in this file overwrite the household relocation rates in the model's settings. telecommute_sqft_per_job_adjusters These are multipliers which adjust the sqft per job setting by superdistrict by year to represent changes from a telework strategy. (TODO: Disentangle the k-factors and the policy application within this file and sqft_per_job_adjusters.csv. In the meantime, use both files as is done in the PBA50 No Project). vmt_fee_zonecats.csv This file pairs with the VMT Fee and SB-743 strategies. It provides VMT levels by TAZ1, which map to the corresponding price adjustments in the strategies. zoning_mods.csv A file which allows you to upzone or downzone. If you enter a value in \"dua_up\" or \"far_up\", the model will apply that as the new zoning or maintain the existing zoning if it is higher. If you enter a value in \"dua_down\" or \"far_down\", the model will apply that as the zoning or maintain the existing zoning if it is lower. UGBs are also controlled using this file, using zoning changes to enforce them. This file is mapped to parcels using the field \"zoningmodcat\", which is the concatenated field of growth designations in parcels_geography.csv."},{"location":"input/#regional_controls","title":"regional_controls/","text":"name description employment_controls.csv The total number of jobs in the region for the model to allocate, by year. The controls are provided by 6-sector job category. household_controls.csv The total number of households in the region for the model to allocate, by year. The controls are provided by household income quartile."},{"location":"input/#zone_forecasts","title":"zone_forecasts/","text":"name description taz_growth_rates_gov_ed.csv This file has ratios of governement and education employment per population by County and TAZ. The files has two header rows prportional_retail_jobs_forecast.csv This contains the field \"minimum_forecast_retail_jobs_per_household\" by jurisdiction, which is used to keep local numbers of retail jobs reasonable through the forecast. tm1_taz1_forecast_inputs.csv This is closely related to regional_controls.csv. These are zone level inputs used for the process of generating variables for the travel model, while the other file contains regional-level controls. These inputs provide TAZ1454 information, used for Travel Model One summaries. tm2_taz2_forecast_inputs.csv The same as above, except these inputs provide TAZ2 information, usED for Travel Model Two summaries. tm1_tm2_maz_forecast_inputs.csv The same as above, except these inputs provide MAZ information, used for btoh Travel Model One and Travel Model Two summaries. tm2_emp27_employment_shares The forecasted share of jobs by 26 sectors, used to apportion that 6 sectors used in the model into more detailed categories Travel Model Two. The shares are provided by county and by year. tm2_occupation_shares The forecasted share of jobs by occupation, used for Travel Model Two. The shares are provided by county and by year. tm1_tm2_regional_controls.csv Controls from the regional forecast which give us employed residents and the age distribution by year, used to forecast variables used by the travel model. tm1_tm2_regional_demographic_forecast Similar to regional_controls.csv, this file provides regional-level information to produce travel model variables, in this case using forecasts of shares by year."},{"location":"model_overview/","title":"Model Overview","text":""},{"location":"model_overview/#approach","title":"Approach","text":"<p>A forecast with BAUS begins with a basemap. This is a detailed geodatabase containing all of the region\u2019s buildings, households, employees, policies, and transport network for a recent year. This roughly corresponds to tooday\u2019s conditions but is a few years in the past due to data collection lag and formalities related to the modeling framework. The buildings are largely an accurate collection of every structure gathered from assessor\u2019s data, commercial read estate databases, and other sources. The households and employees are represented at the micro level but their characteristics are built through synthesis (i.e., we only have samples of this informations so we build a full representation that is consistent with these samples). Policies such as zoning and growth limits are collected for each jurisdiction and are binding unless they are explicitly changed for a forecast.</p> <p>BAUS is used to forecast the future by advancing through repeated steps that chart out a potential pathway for future urban growth. In BAUS each step represents a five year period. Most steps repeat the same set of sub-steps. In UrbanSim, each of these sub-steps is called a \u201cmodel\u201d. The file used to run BAUS (baus.py) sets the number steps and the order in which the models are are run. The major types of model steps are:</p> <ul> <li>(Hazards): This optional model simulates the impact of earthquakes and sea level rise by destroying buildings and displacing their inhabitants.</li> <li>Calculate accessibility: Logsum accessibility measures are brought in from the Travel Model and pedestrian accessibility is calculated within UrbanSim</li> <li>Calculate housing prices and rents: Hedonic regression models are applied to current (to the model time step) conditions to reestimate current prices and rents</li> <li>HH/employee relcation and transition: Some households and employeees are selected to move; additiional households and employees are added or subtracted to reflect the exogenous control totals</li> <li>Add buildings from the Development Projects list: Buildings are forced into the model (as opposed to being explicitly modeled); these represent institutional plans (e.g., universities and hospitals), large approved projects (e.g., Treasure Island), and development that has occurred between the basemap year and the current year (i.e., constructed 2016-2020).</li> <li>Build new market-rate housing units and commercial space: The for-profit real estate development process is simulated and new buildings are built where they are most feasible; this also build deed-restricted unit that are produced through the market-rate process (e.g., inclusionary zoning).</li> <li>Build new deed-restricted affordable units: A similar not-for-profit real estate development process produces affordable housing units based on money available within BAUS Accounts (e.g., bond measures). HH/employee location choices: Households and employees are assigned to new locations based on logistic regresssion models that capture the preferences of particular segments (e.g., lower income households, retail jobs).</li> <li>Produce summary tables: Numerous zonal summaries of the detailed geodatabaase are produced for analysis of urban change and for use in the Travel Model; this step includes additional post-processing to get the data ready for the Travel Model\u2019s population synthesizer.</li> </ul>"},{"location":"model_overview/#sub-models","title":"Sub-Models","text":"<p>Typically, a set of BAUS inputs or assumptions are modified to produce a scenario. Policies such as zoning or fees can be modified. Control totals can be adjusted. Assumptions about preferences or financical situations can be adjusted. The package of changes is then simulated to forecast its impact on the future urban landscape and these outcomes are often enterered into the travel model to predict future year travel patterns and greenhouse gas emmissions.</p>"},{"location":"model_overview/#application-types","title":"Application Types","text":"<p>BAUS is used for for three typical types of application:</p> <ul> <li>Forecasting: UrbanSim produces a complete map for each five year interval into the future. This information is required by statute and useful for planning processes.</li> <li>Policy Studies: BAUS can evaluate the impact of policy changes on, for example, the amount of housing produced, the amount of deed-restricted housing producded, and the locations of future residential or commercial development.</li> <li>Transport Project Evaluation: BAUS provides information on future land use patterns used to evaluate the benefits and costs of large transport infrastructure investments and allows an assessment of how such projects may influence future development.</li> </ul>"},{"location":"model_overview/#model-system","title":"Model System","text":"<p>BAUS is the middle model in an interactive suite of three model systems maintained by MTC:</p> <p>Regional economic and demographic information is supplied to BAUS from the REMI CGE model and related demographic processing scripts. BAUS outputs on housing production are used to adjust regional housing prices (and thus other variables) in REMI. Accessibillity information is supplied to BAUS from the Travel Model and influences real estate prices and household and employee location choices. BAUS outputs on the location of various types of households and employees are used to establish origins and destinations in the Travel Model.</p>"},{"location":"model_overview/#an-overview-of-bauspy","title":"An overview of baus.py","text":"<p>baus.py is a command line interface (cli) used to run Bay Area UrbanSim in various modes.  These modes currently include:</p> <ul> <li>estimation, which runs a series of models to save parameter estimates for all statistical models</li> <li>simulation, which runs all models to create a simulated regional growth forecast</li> <li>fetch_data, which downloads large data files from Amazon S3 as inputs for BAUS</li> <li>preprocessing, which performas long-running data cleaning steps and writes newly cleaned data back to the binary h5 file for use in the other steps</li> <li>baseyearsim which runs a \"base year simulation\" which summarizes the data before the simulation runs (during simulation, summaries are written after each year, so the first year's summaries are after the base year is finished - a base year simulation writes the summaries before any models have run)</li> </ul>"},{"location":"model_overview/#urban-analytics-lab-ual-improvements","title":"Urban Analytics Lab (UAL) Improvements","text":""},{"location":"model_overview/#data-schemas","title":"Data schemas","text":"<ul> <li>Builds out the representation of individual housing units to include a semi-persistent tenure status, which is assigned based on characteristics of initial unit occupants</li> <li>Joins additional race/ethnicity PUMS variables to synthetic households [NB: currently missing from the reconciled model, but will be re-added]</li> <li>Adds a representation of market rents alongside market sale prices</li> </ul>"},{"location":"model_overview/#model-steps","title":"Model steps","text":"<ul> <li>Residential hedonics predict market rents and sale prices separately, with rents estimated from Craigslist listings</li> <li>Household move-out choice is conditional on tenure status</li> <li>Household location choice is modeled separately for renters and owners, and includes race/ethnicity measures as explanatory variables</li> <li>Developer models are updated to produce both rental and ownership housing stock</li> </ul> <p>Notebooks, work history, code samples, etc are kept in a separate bayarea_urbansim_work repository. </p>"},{"location":"model_overview/#current-status-august-2016","title":"Current status (August 2016)","text":"<ul> <li>All of the UAL alterations have been refactored as modular orca steps</li> <li>This code is contained in <code>baus/ual.py</code>, <code>configs/ual_settings.yaml</code> and individual <code>yaml</code> files as needed for regression models that have been re-estimated</li> <li>There are no changes to <code>urbansim</code>, <code>urbansim_defaults</code>, or MTC's orca initialization and model steps</li> <li>MTC and UAL model steps can be mixed and matched by passing different lists to orca; see <code>run.py</code> for examples</li> <li>The UAL model steps document and test for required data characteristics, using the orca_test library</li> </ul>"},{"location":"model_overview/#outputs-from-simulation-written-to-the-runs-directory","title":"Outputs from Simulation (written to the runs directory)","text":"<p>ALL OUTPUT IN THIS DIRECTORY IS NOT OFFICIAL OUTPUT. PLEASE CONTACT MTC FOR OFFICIAL OUTPUTS OF THE LAST PLAN BAY AREA.</p> <p><code>[num]</code> = a positive integer used to identify each successive run.  This number usually starts at 1 and increments each time baus.py is called.</p> <p>Many files are output to the <code>runs/</code> directory. They are described below.</p> filename description run[num]_topsheet_[year].csv An overall summary of various housing and employment outcomes summarized by very coarse geographies. run[num]_parcel_output.csv A csv of all new built space in the region, not including ADUs added to existing buildings.  This has a few thousand rows and dozens of columns which contain various inputs and outputs, as well as debugging information which helps explain why each development was picked by UrbanSim. run[num]_parcel_data_[year].csv A CSV with parcel level output for all parcels with lat, lng and includes change in total_residential_units and change in total_job_spaces, as well as zoned capacity measures. run[num]_building_data_[year].csv The same as above but for buildings. run[num]_taz_summaries_[year].csv A CSV for input to the MTC travel model run[num]_pda_summaries_[year].csv, run[num]_juris_summaries_[year].csv, run[num]_superdistrict_summaries_[year].csv Similar outputs to the taz summaries but for each of these geographies.  Used for understanding the UrbanSim forecast at an aggregate level. run[num]_acctlog_[account name]_[year].csv A series of CSVs of each account's funding amount and buildings developed under this acount (if the funding is used to subsidize development) in each iteration. run[runnum]_dropped_buildings.csv A summary of buildings which were redeveloped during the simulated forecast. run[runnum]_simulation_output.json Used by the web output viewer."},{"location":"model_overview/#directory-structure","title":"Directory structure","text":"<ul> <li>baus/ contains all the Python code which runs the BAUS model.</li> <li>data/ contains BAUS inputs which are small enough to store and render in GitHub (large files are stored on Amazon S3) - this also contains lots of scenario inputs in the form of csv files.  See the readme in the data directory for detailed docs on each file.</li> <li>configs/ contains the model configuration files used by UrbanSim.  This also contains settings.yaml which provides simulation inputs and settings in a non-tabular form. </li> <li>scripts/ these are one-off scripts which are used to perform various input munging and output analysis tasks.  See the docs in that directory for more information.</li> </ul>"},{"location":"model_overview/#a-list-of-features-available-in-baus","title":"A list of features available in BAUS","text":""},{"location":"model_overview/#data-management","title":"Data management","text":"<ul> <li> <p>Add manual_edits.csv to edit individual attributes for each building/parcel in the building and parcel tables</p> </li> <li> <p>An orca step to correct the baseyear vacancies on the job side which happens pre-simulation</p> </li> <li> <p>Do job assignment by starting with baseyear controls and assigning on the fly (should do the same for households)</p> </li> <li> <p>Randomly assign deed restricted units within a zone because that's the most specific data would could get</p> </li> </ul>"},{"location":"model_overview/#run-management","title":"Run management","text":"<ul> <li>Ability to run different model sets, output to Slack and web maps (in baus.py)</li> </ul>"},{"location":"model_overview/#standard-or-extensions-to-urbansim-features","title":"Standard (or extensions to) UrbanSim features","text":"<ul> <li> <p>Houshold and job control totals by year</p> </li> <li> <p>Standard UrbanSim models - hedonic, location choice, transition, relocation models</p> </li> <li> <p>Basic supply and demand interactions to raise prices where demand exceeds supply</p> </li> <li> <p>Separate low and high income hlcms for the deed restricted units</p> </li> <li> <p>1300 lines of computed columns to support the functionality described above</p> </li> </ul>"},{"location":"model_overview/#accessibility-variables","title":"Accessibility variables","text":"<ul> <li> <p>Accessibility variables including special \"distance to location\" variables</p> </li> <li> <p>Both local (local street network from OSM) and regional (travel model network) networks</p> </li> <li> <p>Network aggregations for prices as well</p> </li> </ul>"},{"location":"model_overview/#human-input-and-overrides-for-specific-models","title":"Human input and overrides for specific models","text":"<ul> <li> <p>Do parcel-by-parcel rejections based on human knowledge to override the model</p> </li> <li> <p>Quite a bit of support by year and by scenario for custom development projects, as well as add vs demolish settings</p> </li> <li> <p>Proportional job model on \"static parcels\".  Static parcels are parcels whose jobs do not enter the relocation model and are auto-marked nodev.  These are e.g. city hall and Berkeley which would never get newly created by the model</p> </li> <li> <p>Relocation rates by taz</p> </li> </ul>"},{"location":"model_overview/#developer-model","title":"Developer model","text":"<ul> <li> <p>Provide baseline zoning using parcel to zoning lookups and then attributes for all the zones in the region (num zones &lt;&lt; num parcels)</p> </li> <li> <p>Do conditional upzoning and downzoning, add and remove building types, all by policy zone</p> </li> <li> <p>Limits - assign all parcels to a \"bucket\" - in this case to a city, but it could be a pda-city intersection.  Limits the amount of res and non-res development that comes from each bucket.  Make sure to do so for all non-res types.</p> </li> <li> <p>A special retail model which takes into account where demand for retail is high (income x households) but supply is low</p> </li> <li> <p>We still need a better way to determine the uses that get built between office / retail / industrial / whatever else</p> </li> <li> <p>A reprocessing of the developer results which adds job spaces to residential buildings at an appropriate rate, a second part of this adds ground floor retail by policy for tall buildings in order to create retail where people live</p> </li> </ul>"},{"location":"model_overview/#tweaks-to-get-more-reasonable-results","title":"Tweaks to get more reasonable results","text":"<ul> <li> <p>A setting which allows a user to disable building a more dense buiding that currently exists in a taz (used when we don't trust zoning much) - we minimize the max_dua or far on each parcel with the max built_dua or far near to that parcel</p> </li> <li> <p>For lack of better land price data, we use land prices proportional to the prevailing price per sqft</p> </li> <li> <p>Add (large) factors to land which is industrial to account for expensive land preparation</p> </li> <li> <p>Price shifters and cost shifters</p> </li> <li> <p>Rules to not consider certain parcels for development, like parcels which contain historical buildings, or have single family homes on small lots</p> </li> </ul>"},{"location":"model_overview/#accounts-system-and-subsidies-for-affordable-housing","title":"Accounts system and subsidies for affordable housing","text":"<ul> <li> <p>\"Lump sump accounts\" which are regional accounts that get a certain subsidy per year and are used to subsidize development in parcels that pass a certain filter and can create affordable housing or not</p> </li> <li> <p>Inclusionary housing rates which decrease revenues by a certain amount based on the AMI in an area and the inclusionary rate in an area - inclusionary housing rates get set by city</p> </li> <li> <p>Other policies which modify revenue as a percent of profit</p> </li> <li> <p>Impact fees which impose a cost per unit or per sqft</p> </li> <li> <p>Subsidized development on both the residential and office sides (not on retail?)</p> </li> <li> <p>Ad hoc \"land value tax\" revenue adjustment</p> </li> </ul>"},{"location":"model_overview/#output-summaries-analysis-and-visualization","title":"Output summaries, analysis and visualization","text":"<ul> <li> <p>Create a topsheet which does very basic one line summaries of a number of different outcomes - write as a text file to Slack so it can be read and reviewed from mobile</p> </li> <li> <p>Geographic summaries of households, jobs, and buildings for each 5 year increment, for superdistrict, pda, and juris geographies</p> </li> <li> <p>Write out disaggregate parcel and building data for visualization with ESRI</p> </li> <li> <p>A utility to compare output summary tables and put them in separate tabs of a workbook and color-code large differences</p> </li> <li> <p>Back into some demographic variables needed by the travel model that aren't produced by our UrbanSim model, including age categories, employed residents (by household location), population (we do households) some legacy land use variables from the previous model</p> </li> <li> <p>The travel model output which summarized some basic variables by zone</p> </li> <li> <p>Write out account information (subsididies and fees)</p> </li> <li> <p>Do urbanfootprint accounting - whether development is inside or outside the \"UGB\"</p> </li> <li> <p>Some extra diagnostic accounting including simple capacity calculations, simulated vacancy rates (for debugging, not as a sim output), sqft by building type</p> </li> <li> <p>Compare household and job counts to abag targets at the pda and juris levels</p> </li> </ul>"},{"location":"models-reference/","title":"Models module","text":""},{"location":"models-reference/#baus.models","title":"<code>baus.models</code>","text":""},{"location":"models-reference/#baus.models.elcm_simulate","title":"<code>elcm_simulate(jobs, buildings, aggregations)</code>","text":"<p>testing docstring documentation for automated documentation creation</p> Source code in <code>baus\\models.py</code> <pre><code>@orca.step()\ndef elcm_simulate(jobs, buildings, aggregations):\n\"\"\"\n    testing docstring documentation for automated documentation creation\n    \"\"\"\n    buildings.local[\"non_residential_rent\"] = \\\n        buildings.local.non_residential_rent.fillna(0)\n    return utils.lcm_simulate(\"location_choice/elcm.yaml\", jobs, buildings, aggregations,\n                              \"building_id\", \"job_spaces\",\n                              \"vacant_job_spaces\", cast=True)\n</code></pre>"},{"location":"output/","title":"Output","text":""},{"location":"output/#the-outputs-of-bay-area-urbansim-baus-and-a-description-of-each-file-model-output-files-are-written-to-an-outputs-folder-during-a-baus-model-run","title":"The outputs of Bay Area UrbanSim (BAUS) and a description of each file. Model output files are written to an <code>outputs</code> folder during a BAUS model run.","text":""},{"location":"output/#outputs","title":"outputs/","text":""},{"location":"output/#core-summaries","title":"core summaries","text":"name description parcel_summary_[year].csv Development, households, and jobs on each parcel in a given year. parcel_growth_summary.csv Change in development, households, and jobs on each parcel between the model's base year and forecast year. building_summary_[year].csv Inventory of buildings in a given year, linked to the parcel they sit on. diagnostic_output.csv Interim model data."},{"location":"output/#geographic-summaries","title":"geographic summaries","text":"name description jurisdiction_summary_[year].csv Jurisdiction-level summary of development, households, and jobs in a given year. jurisdiction_summary_growth.csv Jurisdiction-level change in development, households, and jobs between the model's base year and forecast year. superdistrict_summary_[year].csv Superdistrict-level summary of development, households, and jobs in a given year. superdistrict_summary_growth.csv Superdistrict-level change in development, households, and jobs between the model's base year and forecast year. county_summary_[year].csv County-level summary of development, households, and jobs in a given year. county_summary_growth.csv County-level change in development, households, and jobs between the model's base year and forecast year. subregion_summary_[year].csv Subregion-level change in development, households, and jobs in a given year. subregion_summary_growth.csv Subregion-level change in development, households, and jobs between the model's base year and forecast year. region_summary_[year].csv Regional summary of development, households, and jobs in a given year. region_summary_growth.csv Regional change in development, households, and jobs between the model's base year and forecast year."},{"location":"output/#travel-model-summaries","title":"travel model summaries","text":"name description taz1_summary_[year].csv TAZ1/TAZ1454-level summaries of development, households, jobs, demographics, and density attributes used for travel modeling. taz1_summary_growth.csv TAZ1/TAZ1454-level change in development, households, jobs, demographics, and density attributes used for travel modeling. maz_marginals_[year].csv MAZ-level summaries of households and demographics used to create the synthesized population for travel modeling. maz_summary_[year].csv MAZ-level summaries of development, households, jobs, and density attributes used for travel modeling. maz_summary_growth.csv MAZ-level change in development, households, jobs, and density attributes used for travel modeling. taz2_marginals_[year].csv TAZ2-level summaries of households and demographics used to create the synthesized population for travel modeling. county_marginals_[year].csv County-level summaries of demographics and jobs used to create the synthesized population for travel modeling. region_marginals_[year].csv Region-level summaries of demographics used to create the synthesized population for travel modeling."},{"location":"output/#affordable-housing-summaries","title":"affordable housing summaries","text":"name description juris_dr_summary_[year].csv Jurisdiction-level summary of deed-restricted units by type in a given year. juris_dr_growth.csv Jurisdiction-level change in deed-restricted units by type between the model's base year and forecast year. superdistrict_dr_summary_[year].csv Superdistrict-level summary of deed-restricted units by type in a given year. superdistrict_dr_growth.csv Superdistrict-level change in deed-restricted units by type between the model's base year and forecast year. county_dr_summary_[growth].csv County-level summary of deed-restricted units by type in a given year. county_dr_growth County-level change in deed-restricted units by type between the model's base year and forecast year. region_dr_summary_[year].csv Region-level summary of deed-restricted units by type in a given year. region_dr_growth.csv Region-level change in deed-restricted units by type between the model's base year and forecast year."},{"location":"output/#hazards-summaries","title":"hazards summaries","text":"name description slr_summary_[year].csv Sea level rise impacted parcels, buildings, households, and jobs in a given year. eq_codes_summary_[year].csv Summary of earthquake codes assigned to buildings, in the earthquake year. eq_fragilities_summary_[year].csv SUmmary of fragilities assigned to buildings, in the earthquake year. slr_summary_[year].csv Earthquake impacted parcels, buildings, households, and jobs in the earthquake year. eq_demolish_buildings_[year].csv Inventory of buildings impacted by earthquake, by TAZ for the resilience team. eq_demolish_buildings_[year].csv Inventory of buildings retrofit for earthquake, by TAZ for the resilience team. eq_buildings_list_[year].csv Inventory of buildings in key earthquake years, by TAZ for the resilience team."},{"location":"output/#metrics","title":"metrics","text":"name description growth_geog_summary_[year].csv Households and jobs in growth geographies and combinations of growth geographies, by year. growth_geog_growth_summary_[year].csv Change in households and jobs in growth geographies and combinations of growth geographies between the model's base year and forecast year. dr_units_metrics.csv Change in deed-restricted units by HRA and COC. household_income_metrics_[year].csv Low income households by growth geography, by year. equity_metrics.csv Change in low income households in Displacement tracts and COC tracts. jobs_housing_metrics.csv Jobs-Housing ratios by county, by year. jobs_metrics.csv Change in PPA and manufacturing jobs. slr_metrics.csv Sea level rise affected and protected total households, low-income households and COC households. earthquake_metrics.csv Total housing units retrofit and total retrofit cost, for all units and for COC units. Earthquake affected and protected total households, low-income households, and COC households. greenfield_metric.csv Change in annual greenfield development acres."},{"location":"pba50/","title":"Plan Bay Area 2050","text":"<p>Background: Plan Bay Area 2050 project website</p>"},{"location":"pba50/#scenarios","title":"Scenarios","text":""},{"location":"pba50/#s21-blueprint-basic","title":"S21: Blueprint Basic","text":"<ul> <li>This is the \"base\" scenario in the sense that we are doing it first and the others build off of it</li> <li>Uses s21 control total files</li> <li>Uses Blueprint Basic logsums</li> <li>Uses s21 zoning modifications: major upzoning in all growth geogs</li> <li>Has almost all strategies in</li> </ul>"},{"location":"pba50/#s20-baseline-for-pba50","title":"s20: Baseline for PBA50","text":"<ul> <li>This is the \"baseline\" scenario in the sense that it doesn't have any pba50 changes and so it also has far lower control totals</li> <li>Uses s20 control total files (these are minus the additional units built bc of housing policy in pba50)</li> <li>Uses Baseline logsums (somewhat less congestion than others?)</li> <li>Uses s20 zoning modifications: these are minimal in that the do typical No Project treatment (UGB, upzoning within) but may also need UGB expansion to fit control totals</li> <li>Has no new strategies from PBA50</li> </ul>"},{"location":"pba50/#s22-blueprint-plus-fix-it-first","title":"s22: Blueprint Plus Fix It First","text":"<ul> <li>This is the higher funding scenario</li> <li>Uses s22 control total files</li> <li>Uses Blueprint Plus Fix It First logsums (very similar to s21 logsums)</li> <li>Uses s22 zoning modifications: same as s21</li> <li>Adds/modifies these strategies (working off of s210:<ul> <li>adds incubator strategy</li> <li>increases size of affordable housing fund</li> <li>more slr protection</li> </ul> </li> </ul>"},{"location":"pba50/#s23-blueprint-plus-crossing","title":"s23: Blueprint Plus Crossing","text":"<ul> <li>This is the higher funding scenario plus the New Transbay Crossing</li> <li>Uses s23 control total files</li> <li>Uses Blueprint Plus Crossing logsums (moderately different from other scenarios)</li> <li>Uses s23 zoning modifications: slightly higher upzoning than s21 and s22 at a few new/upgraded stations</li> <li>Same strategies as s22</li> </ul>"},{"location":"pba50/#s24-final-blueprint","title":"s24: Final Blueprint","text":"<ul> <li>Builds off of s23</li> <li>Includes both error correction and policy modifications</li> </ul>"},{"location":"pba50/#strategy-coding-technical-notes","title":"Strategy Coding Technical Notes","text":""},{"location":"pba50/#deed-restricted-units-notes","title":"Deed-Restricted Units notes","text":"<ul> <li>Deed-restricted units can now come from many sources. As of Final Blueprint, those sources are:<ul> <li>DR = base year DR + pipeline DR + public lands (added via pipeline) + subsidized (production) + preserved + inclusionary</li> </ul> </li> <li>Pipeline units cannot be redeveloped, other deed-restricted units can if or when the building is more than 20 years old. </li> <li>In the household location choice models, only Q1 households can enter DR units. However, if the model can't find enough Q1 households for the DR units (due to modeling reasons or over-supply) non-Q1 households are able to enter. </li> </ul>"},{"location":"pba50/#affordable-housing-fund-preservation-final-blueprint","title":"Affordable Housing Fund- Preservation (Final Blueprint)","text":"<ul> <li>Selects buildings to spend preservation funding on, by marking them as deed restricted units. The selection is not tied to price, and housing cost is calculated off model. <ul> <li>The buildings are randomly selected based on the total number of buildings to preserve within a geography which are set here. </li> <li>The \"deed restricted\" column is updated in the residential units table, which is used to filter units in the household location choice models and assign Q1 households to deed restricted units. The \"deed restricted units\" and \"preserved units\" columns are updated in the buildings table. These occur here.</li> </ul> </li> <li>In some cases, a Q1 household will already occupy a newly preserved unit. If that household moves, only another Q1 will be able to move in. In other cases, a non-Q1 household will occupy a newly preserved unit, and a Q1 household is only able to enter if and when that household moves out. </li> </ul>"},{"location":"pba50/#inclusionary-zoning-draft-blueprint-final-blueprint","title":"Inclusionary Zoning (Draft Blueprint, Final Blueprint)","text":"<ul> <li>Inclusionary zoning requirement (x% of new housing development have to be affordable) is set in policy.yalm.<ul> <li>The default setting represents the existing requirements without plan strategy interventions.</li> <li>Plan strategies are organized by scenario, with a scenario handler at the top.</li> <li>Inclusionary rate is set at certain geographic level: <ul> <li>PBA40 and Horizon: inclusionary percentage by jurisdiction. </li> <li>Draft Blueprint: inclusionary percentage by pba50chcat (i.e. the combination of several growth geography strategies, GG, TRA, PPA, etc.). </li> <li>Final Blueprint: inclusionary percentage by fbpchcat.</li> </ul> </li> </ul> </li> <li>Coding notes:<ul> <li>datasources.py reads inclusionary strategy input and maps it to parcels using the corresponding field: PBA40 and Horizon uses 'jurisdiction', Draft Blueprint uses 'pba50chcat', Final Blueprint uses 'fbpchcat'.</li> <li>In subsidies.py, the inclusionary_housing_revenue_reduction function calculates median household AMI, feasible new affordable housing count and revenue_reduction amount of each inclusionary geography. In PBA40 and Horizon, these calculations were conducted at the jurisdiction level. PBA50 uses strategy geographies instead - 'pba50chcat' in Draft Blueprint and 'fbpchcat' in Final Blueprint.</li> <li>The inclusionary statements in summaries.py should be consistent with the inclusionary geography of each plan scenario.</li> </ul> </li> </ul>"},{"location":"pba50/#reduce-cost-for-housing-development-draft-blueprint-final-blueprint","title":"Reduce cost for housing development (Draft Blueprint, Final Blueprint)","text":"<ul> <li>One way to (indirectly) subsidize housing is to reduce housing development cost reduction, for example, SB743 CEQA reform, lowering parking requirements, etc. This is defined in profitability_adjustment_policies. The policies are scenario-based, as noted by \"enable_in_scenarios\". For each policy, profitabiity_adjustment_formula picks the parcels in a certain category (e.g. a certain type of geography) and then decreases the required profitability level needed for the model to build on those parcels, e.g. multiplying by 2.5% or 0.025 means to LOWER the required profit level by 2.5%. When a policy has an alternative version is different scenarios, may use 'alternative_geography_scenarios' and 'alternative_adjustment_formula' to consolidate the scenarios.</li> <li>\"Summaries.py\" summaries these policies.</li> </ul>"},{"location":"pba50/#affordable-housing-fund-lump-sum-account-draft-blueprint-final-blueprint","title":"Affordable Housing Fund Lump-sum Account (Draft Blueprint, Final Blueprint)","text":"<ul> <li> <p>Lump-sum accounts represent direct housing subsidies. </p> <ul> <li>Each county has a <code>lump-sum account</code> to hold all the available affordable housing funding for that county. BAUS assumes a constant annual funding amount (an independent input), for each county during the plan period, doesn't consider inflation or fluctuations in funding availability over time. In each simulation iteration, funding available in each county's account equals the annual amount multiplies by years per iteration (5 years in BAUS). </li> <li>Residential development projects that are not feasible under market conditions are potentially qualified for subsidy. Final Blueprint requires the projects to be also located within the Growth Geography. A qualified project draws money from the corresponding account to fill the feasibility gap. Not all qualified projects will be subsidized.</li> <li>Lum-sum accounts are scenario-based, having scenario-specific fund amount and project qualification criteria.</li> </ul> </li> <li> <p>Coding notes:</p> <ul> <li>Set up the account in policy.yaml</li> <li>Calculate each account's subsidy amount for each iteration and add it to coffer</li> <li>Set up the filter in <code>run_subsidized_developer()</code></li> <li>Update the config in 'summaries.py'</li> <li>Check <code>subsidized_residential_developer_lump_sum_accts()</code>  and make sure it is included in the model list in <code>baus.py</code></li> </ul> </li> </ul>"},{"location":"pba50/#vmt-fees-transportation-impact-fees-draft-blueprint","title":"VMT Fees / Transportation Impact Fees (Draft Blueprint)","text":"<ul> <li>Apply fees on new commercial or residential development that reflects transportation impacts associated with such development, focusing primarily on new commercial spaces or residential units anticipated to have high employment-related or residence-related vehicle miles traveled (VMT). The fees could be set at county, jurisdiction, or TAZ level, usually on a $/sqft basis for commercial development and $/unit basis for residential development. Draft Blueprint applies VMT on new office development based on the county and associated VMT per worker associated with the TAZ to incentivize development inside low-VMT job centers.</li> <li>This diagram illustrates the modeling steps in BAUS:<ul> <li>BAUS has three types of VMT fees - \"com_for_res\" (apply fees on commercial development to subsidize residential development), \"res_for_res\" (apply fees on residential development to subsidize residential development), and \"com_for_com\" (apply fees on commercial development to subsidize commercial development). </li> <li>Each parcel is assigned a \"vmt_res_cat\" value and a \"vmt_nonres_cat\" value based on its categorized VMT-level. This is then mapped to the fee table to decide the fee amount for new residential and commercial development on the parcel.</li> <li>During each model iteration period (currently five years), VMT fees collected from new development go into one of the two accounts - \"vmt_res_acct\" and \"vmt_com_acct\" - for each geography (regional or sub-regional). Policies that aim to support/incentivize certain types of housing development or commercial activities can draw funding from respective account. In Draft Blueprint, VMT fees revenue is not applied into any job/housing incentive, but is accumulated to help to understand how much revenue is raised to support other economy strategies.</li> </ul> </li> </ul>"},{"location":"pba50/#jobs-housing-balance-fee-draft-blueprint","title":"Jobs-housing Balance Fee (Draft Blueprint)","text":"<ul> <li>Apply a regional jobs-housing linkage fee to generate funding for affordable housing when new office development occurs in job-rich places, thereby incentivizing more jobs to locate in housing-rich places. The $/sqft fee assigned to each jurisdiction is a composite fee based on the jobs-housing ratio and jobs-housing fit for both cities and counties.</li> <li>Modeling jobs-housing fee in BAUS:<ul> <li>Jobs-housing fee is tracked in BAUS under the \"jobs_housing_com_for_res\" account at the county level, which is similar to the \"com_for_res\" account of the VMT strategy.</li> <li>In each model interation period, jobs-housing fees applies to new office development in each county based on the $/sqft level of jurisdiction where the development occurs. The fees collected goes to each county's account. </li> <li>The account then acts similarly to the county-level lump-sum account to subsidize affordable housing in that county. </li> </ul> </li> </ul>"},{"location":"pba50/#office-lump-sum-account-final-blueprint","title":"Office Lump Sum Account (Final Blueprint)","text":"<ul> <li>Similar to the residential funding lump sum account, office lump sum account provides funding to subsidize office development in targeted areas. </li> </ul>"},{"location":"subsidies-reference/","title":"Subsidies module","text":""},{"location":"subsidies-reference/#baus.subsidies","title":"<code>baus.subsidies</code>","text":""},{"location":"subsidies-reference/#baus.subsidies.run_subsidized_developer","title":"<code>run_subsidized_developer(feasibility, parcels, buildings, households, acct_settings, developer_settings, account, year, form_to_btype_func, add_extra_columns_func, summary, create_deed_restricted=False, policy_name='Unnamed')</code>","text":"<p>The subsidized residential developer model.</p>"},{"location":"subsidies-reference/#baus.subsidies.run_subsidized_developer--parameters","title":"Parameters","text":"DataFrame <p>A DataFrame that is returned from run_feasibility for a given form</p> DataFrameWrapper <p>The standard parcels DataFrameWrapper (mostly just for run_developer)</p> DataFrameWrapper <p>The standard buildings DataFrameWrapper (passed to run_developer)</p> DataFrameWrapper <p>The households DataFrameWrapper (passed to run_developer)</p> Dict <p>A dictionary of settings to parameterize the model.  Needs these keys: sending_buildings_subaccount_def - maps buildings to subaccounts receiving_buildings_filter - filter for eligible buildings</p> Dict <p>The overall settings</p> Account <p>The Account object to use for subsidization</p> int <p>The current simulation year (will be added as metadata)</p> function <p>Passed through to run_developer</p> function <p>Passed through to run_developer</p> Summary <p>Used to add parcel summary information</p> bool <p>Bool for whether to create deed restricted units with the subsidies or not.  The logic at the time of this writing is to keep track of partial units so that when partial units sum to greater than a unit, that unit will be deed restricted.</p>"},{"location":"subsidies-reference/#baus.subsidies.run_subsidized_developer--returns","title":"Returns","text":"<p>Nothing</p> <p>Subsidized residential developer is designed to run before the normal residential developer - it will prioritize the developments we're subsidizing (although this is not strictly required - running this model after the market rate developer will just create a temporarily larger supply of units, which will probably create less market rate development in the next simulated year). The steps for subsidizing are  essentially these:</p> <p>1 run feasibility with only_built set to false so that the feasibility of unprofitable units are recorded 2 temporarily filter to ONLY unprofitable units to check for possible subsidized units (normal developer takes care of market-rate units) 3 compute the number of units in these developments 4 divide cost by number of units in order to get the subsidy per unit 5 filter developments to parcels in \"receiving zone\" similar to the way we identified \"sending zones\" 6 iterate through subaccounts one at a time as subsidy will be limited to available funds in the subaccount (usually by jurisdiction) 7 sort ascending by subsidy per unit so that we minimize subsidy (but total subsidy is equivalent to total building cost) 8 cumsum the total subsidy in the buildings and locate the development     where the subsidy is less than or equal to the amount in the account - filter to only those buildings (these will likely be built) 9 pass the results as \"feasible\" to run_developer - this is sort of a boundary case of developer but should run OK 10 for those developments that get built, make sure to subtract from account and keep a record (on the off chance that demand is less than     the subsidized units, run through the standard code path, although it's very unlikely that there would be more subsidized housing than      demand)</p> Source code in <code>baus\\subsidies.py</code> <pre><code>def run_subsidized_developer(feasibility, parcels, buildings, households, acct_settings, developer_settings, account, year, form_to_btype_func, \n                             add_extra_columns_func, summary, create_deed_restricted=False, policy_name=\"Unnamed\"):\n\"\"\"\n    The subsidized residential developer model.\n\n    Parameters\n    ----------\n    feasibility : DataFrame\n        A DataFrame that is returned from run_feasibility for a given form\n    parcels : DataFrameWrapper\n        The standard parcels DataFrameWrapper (mostly just for run_developer)\n    buildings : DataFrameWrapper\n        The standard buildings DataFrameWrapper (passed to run_developer)\n    households : DataFrameWrapper\n        The households DataFrameWrapper (passed to run_developer)\n    acct_settings : Dict\n        A dictionary of settings to parameterize the model.  Needs these keys: sending_buildings_subaccount_def - maps buildings to subaccounts\n        receiving_buildings_filter - filter for eligible buildings\n    settings : Dict\n        The overall settings\n    account : Account\n        The Account object to use for subsidization\n    year : int\n        The current simulation year (will be added as metadata)\n    form_to_btype_func : function\n        Passed through to run_developer\n    add_extra_columns_func : function\n        Passed through to run_developer\n    summary : Summary\n        Used to add parcel summary information\n    create_deed_restricted : bool\n        Bool for whether to create deed restricted units with the subsidies or not.  The logic at the time of this writing is to keep track of\n        partial units so that when partial units sum to greater than a unit, that unit will be deed restricted.\n\n    Returns\n    -------\n    Nothing\n\n    Subsidized residential developer is designed to run before the normal residential developer - it will prioritize the developments we're\n    subsidizing (although this is not strictly required - running this model after the market rate developer will just create a temporarily larger\n    supply of units, which will probably create less market rate development in the next simulated year). The steps for subsidizing are \n    essentially these:\n\n    1 run feasibility with only_built set to false so that the feasibility of unprofitable units are recorded\n    2 temporarily filter to ONLY unprofitable units to check for possible subsidized units (normal developer takes care of market-rate units)\n    3 compute the number of units in these developments\n    4 divide cost by number of units in order to get the subsidy per unit\n    5 filter developments to parcels in \"receiving zone\" similar to the way we identified \"sending zones\"\n    6 iterate through subaccounts one at a time as subsidy will be limited to available funds in the subaccount (usually by jurisdiction)\n    7 sort ascending by subsidy per unit so that we minimize subsidy (but total subsidy is equivalent to total building cost)\n    8 cumsum the total subsidy in the buildings and locate the development\n        where the subsidy is less than or equal to the amount in the account - filter to only those buildings (these will likely be built)\n    9 pass the results as \"feasible\" to run_developer - this is sort of a boundary case of developer but should run OK\n    10 for those developments that get built, make sure to subtract from account and keep a record (on the off chance that demand is less than\n        the subsidized units, run through the standard code path, although it's very unlikely that there would be more subsidized housing than \n        demand)\n    \"\"\"\n    # step 2\n    feasibility = feasibility.replace([np.inf, -np.inf], np.nan)\n    feasibility = feasibility[feasibility.max_profit &lt; 0]\n\n    # step 3\n    feasibility['ave_sqft_per_unit'] = parcels.ave_sqft_per_unit\n    feasibility['residential_units'] = np.floor(feasibility.residential_sqft / feasibility.ave_sqft_per_unit)\n\n    # step 3B\n    # can only add units - don't subtract units - this is an approximation\n    # of the calculation that will be used to do this in the developer model\n    feasibility = feasibility[feasibility.residential_units &gt; feasibility.total_residential_units]\n\n    # step 3C\n    # towards the end, because we're about to sort by subsidy per unit, some\n    # large projects never get built, because it could be a 100 unit project\n    # times a 500k subsidy per unit.  thus we're going to try filtering by\n    # the maximum subsidy for a single development here\n    feasibility = feasibility[feasibility.max_profit &gt; -50*1000000]\n\n    # step 4\n    feasibility['subsidy_per_unit'] = -1 * feasibility['max_profit'] / feasibility['residential_units']\n    # assumption that even if the developer says this property is almost\n    # profitable, even the administration costs are likely to cost at least\n    # 10k / unit\n    feasibility['subsidy_per_unit'] = feasibility.subsidy_per_unit.clip(10000)\n\n    # step 5\n    if \"receiving_buildings_filter\" in acct_settings:\n        feasibility = feasibility.query(acct_settings[\"receiving_buildings_filter\"])\n    else:\n        # otherwise all buildings are valid\n        pass\n\n    new_buildings_list = []\n    sending_bldgs = acct_settings[\"sending_buildings_subaccount_def\"]\n    feasibility[\"regional\"] = 1\n    feasibility[\"subaccount\"] = feasibility.eval(sending_bldgs)\n    # step 6\n    for subacct, amount in account.iter_subaccounts():\n        print(\"Subaccount: \", subacct)\n\n        df = feasibility[feasibility.subaccount == subacct]\n        print(\"Number of feasible projects in receiving zone:\", len(df))\n\n        if len(df) == 0:\n            continue\n\n        # step 7\n        df = df.sort_values(['subsidy_per_unit'], ascending=True)\n        # df.to_csv('subsidized_units_%d_%s_%s.csv' % (orca.get_injectable(\"year\"), account.name, subacct))\n\n        # step 8\n        print(\"Amount in subaccount: ${:,.2f}\".format(amount))\n        num_bldgs = int((-1*df.max_profit).cumsum().searchsorted(amount))\n\n        if num_bldgs == 0:\n            continue\n\n        # technically we only build these buildings if there's demand\n        # print \"Building {:d} subsidized buildings\".format(num_bldgs)\n        df = df.iloc[:int(num_bldgs)]\n\n        df.columns = pd.MultiIndex.from_tuples(\n            [(\"residential\", col) for col in df.columns])\n        # disable stdout since developer is a bit verbose for this use case\n        sys.stdout, old_stdout = StringIO(), sys.stdout\n\n        kwargs = developer_settings['residential_developer']\n        # step 9\n        new_buildings = utils.run_developer(\n            \"residential\",\n            households,\n            buildings,\n            \"residential_units\",\n            parcels.parcel_size,\n            parcels.ave_sqft_per_unit,\n            parcels.total_residential_units,\n            orca.DataFrameWrapper(\"feasibility\", df),\n            year=year,\n            form_to_btype_callback=form_to_btype_func,\n            add_more_columns_callback=add_extra_columns_func,\n            profit_to_prob_func=profit_to_prob_func,\n            **kwargs)\n        sys.stdout = old_stdout\n        buildings = orca.get_table(\"buildings\")\n\n        if new_buildings is None:\n            continue\n\n        # keep track of partial subsidized untis so that we always get credit\n        # for a partial unit, even if it's not built in this specific building\n        partial_subsidized_units = 0\n\n        # step 10\n        for index, new_building in new_buildings.iterrows():\n\n            amt = new_building.max_profit\n            metadata = {\n                \"description\": \"Developing subsidized building\",\n                \"year\": year,\n                \"residential_units\": new_building.residential_units,\n                \"inclusionary_units\": new_building.inclusionary_units,\n                \"building_id\": index\n            }\n\n            if create_deed_restricted:\n\n                revenue_per_unit = new_building.building_revenue / new_building.residential_units\n                total_subsidy = abs(new_building.max_profit)\n                subsidized_units = total_subsidy / revenue_per_unit + partial_subsidized_units\n                # right now there are inclusionary requirements\n                already_subsidized_units = new_building.deed_restricted_units\n\n                # get remainder\n                partial_subsidized_units = subsidized_units % 1\n                # round off for now\n                subsidized_units = int(subsidized_units) + already_subsidized_units\n                # cap at number of residential units\n                subsidized_units = min(subsidized_units, new_building.residential_units)\n\n                buildings.local.loc[index, \"deed_restricted_units\"] = int(round(subsidized_units))\n\n                buildings.local.loc[index, \"subsidized_units\"] = buildings.local.loc[index, \"deed_restricted_units\"] - \\\n                    buildings.local.loc[index, \"inclusionary_units\"]\n\n                # also correct the debug output\n                new_buildings.loc[index, \"deed_restricted_units\"] = int(round(subsidized_units))\n                new_buildings.loc[index, \"subsidized_units\"] = new_buildings.loc[index, \"deed_restricted_units\"] - \\\n                    new_buildings.loc[index, \"inclusionary_units\"]\n\n            metadata['deed_restricted_units'] = new_buildings.loc[index, 'deed_restricted_units']\n            metadata['subsidized_units'] = new_buildings.loc[index, 'subsidized_units']\n            account.add_transaction(amt, subaccount=subacct, metadata=metadata)\n\n        # turn off this assertion for the Draft Blueprint affordable housing policy since the number of deed restricted units\n        # vs units from development projects looks reasonable\n#        assert np.all(buildings.local.deed_restricted_units.fillna(0) &lt;=\n#                      buildings.local.residential_units.fillna(0))\n\n        print(\"Amount left after subsidy: ${:,.2f}\".format(account.total_transactions_by_subacct(subacct)))\n\n        new_buildings_list.append(new_buildings)\n\n    total_len = reduce(lambda x, y: x+len(y), new_buildings_list, 0)\n    if total_len == 0:\n        print(\"No subsidized buildings\")\n        return\n\n    new_buildings = pd.concat(new_buildings_list)\n    print(\"Built {} total subsidized buildings\".format(len(new_buildings)))\n    print(\"    Total subsidy: ${:,.2f}\".format(-1*new_buildings.max_profit.sum()))\n    print(\"    Total subsidized units: {:.0f}\".format(new_buildings.residential_units.sum()))\n\n    new_buildings[\"subsidized\"] = True\n    new_buildings[\"policy_name\"] = policy_name\n\n    summary.add_parcel_output(new_buildings)\n</code></pre>"},{"location":"user_guide/","title":"User Guide","text":"<p>This User Guide applies to UrbanSim implementation for the Bay Area. Documentation for the UrbanSim framework is available here.</p>"},{"location":"user_guide/#installation","title":"Installation","text":"<p>Bay Area UrbanSim is written in Python and runs in a command line environment. It's compatible with Mac, Windows, and Linux, and with Python 2.7 and 3.5+. Python 3 is recommended.</p> <ol> <li>Install the Anaconda Python distribution (not strictly required, but makes things easier and more reliable)</li> <li>Clone this repository</li> <li>Download base data from this Box folder and move the files to <code>bayarea_urbansim/data/</code> (ask an MTC contact for access)</li> <li>Clone the MTC urban_data_internal repository to the same location as this repository (ask an MTC contact for access)</li> <li>Create a Python environment with the current dependencies: <code>conda env create -f baus-env-2020.yml</code></li> <li>Activate the environment: <code>conda activate baus-env-2020</code></li> <li>Pre-process the base data: <code>python baus.py --mode preprocessing</code> (only needed once)</li> <li>Run the model: <code>python baus.py</code> (typical AWS linux run uses <code>nohup python baus.py -s 25 --disable-slack --random-seed &amp;</code> which add no hanging up / specifies scenario 25 / disables slack output / turns OFF random seed / puts in background)</li> </ol> <p>More info about the command line arguments: <code>python baus.py --help</code></p> <p>Optional visualization tool and Slack messenger:</p> <ul> <li>Configure Amazon Web Services (AWS) to get s3 permission (you will need an appropriately configured AWS credentials file from your MTC contact)</li> <li>Install AWS SDK for Python -- boto3 using <code>pip install boto3</code></li> <li>Install Slacker to use Slack API using <code>pip install slacker</code> (you will need an appropriate slack token to access the slack bot from your MTC contact)</li> <li>Set environment variable <code>URBANSIM_SLACK = TRUE</code></li> </ul>"},{"location":"user_guide/#file-structure","title":"File Structure","text":"<p>TBD</p>"}]}